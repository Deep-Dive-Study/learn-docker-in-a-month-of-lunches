# 20장 리버스 프록시를 이용해 컨테이너 HTTP 트래픽 제어하기
- 외부에서 들어온 트래픽을 컨테이너까지 이어 주는 라우팅은 도커 엔진이 담당함
- 리버스 프록시는 컨테이너 환경에 적합한 애플리케이션 설계에서 매우 중요한 역할을 함
  - 로드 밸런싱, 캐싱, 암호화, 등
 
## 20.1 리버스 프록시란?
- 프록시란 대리자라는 의미로 어떤 요청이나 트래픽, 등을 대신하여 처리하는 요소를 의미함
  - 네트워크에서 프록시란, 네트워크상의 다른 구성 요소를 대신하여 네트워크 트래픽을 처리하는 구성 요소
  - 웹 브라우저에서 전달되는 요청을 가로채 허용된 사이트인지 확인하거나, 빠른 속도를 위해 캐싱을 제공, 혹은 암호화 처리를 돕기 위해, 등 다양한 목적으로 활용됨

- 리버스 프록시도 이와 유사하며 여러 웹 애플리케이션으로 통하는 관문의 역할을 담당함
  - 엄밀하게 따지면, API Gateway와 차이가 있다는 논란이 있으나, 보통은 동일한 의미, 역할로 사용함
  - 해당 트래픽이 어떤 어플리케이션에서 출발했는지 판단, 응답 내용 캐싱, 암호화, 등
 
    ![CleanShot 2024-12-22 at 21 08 00@2x](https://github.com/user-attachments/assets/d0a7ddcd-7d6c-49a0-8d8e-e8b4906669e4)
  
    - 포트를 외부에 노출한 유일한 컨테이너
    - 외부에서 들어오는 모든 요청을 먼저 받고 그에 맞는 컨테이너로부터 응답을 받아옴
    - 이러한 방식은 스케일링, 업데이트, 보안 측면에서 유리함

## 20.2 리버스 프록시의 라우팅과 SSL 적용하기
- 리버스 프록시의 역할을 하는 엔진엑스를 활용하면 SSL 처리도 가능하며, 로드 밸런싱도 할 수 있음
- 쿠버네티스 없이도 코드의 영향을 주지 않고 인프라 영역에서 이러한 동작이 가능함
  - 사실 엔진엑스와 같은 동작을 하는 클라우드 컴포넌트로는 ALB가 있음
  - HA Proxy도 자주 사용됨(https://code-killer.tistory.com/157)
 
- 이전에 사이드 프로젝트(KKINI & Habiters)했을 당시에 Nginx를 활용하여 로드 밸런싱(블루 그린 배포) 및 Let's Encrypt SSL 암호화를 적용함

  ![Google Chrome 2024-12-22 21 55 33](https://github.com/user-attachments/assets/7e7526c4-3397-40e0-aa9c-f071bd4da980)

  ![CleanShot 2024-12-22 at 22 00 11@2x](https://github.com/user-attachments/assets/ded3efc7-b394-4485-8a01-0d27a8f584d6)

## 20.3 프록시를 이용한 성능 및 신뢰성 개선
- 리버스 프록시를 사용하면 웹의 성능을 개선할 수 있음
  - 정적 파일을 제공하거나, 캐싱 프록시로서 사용할 수 있음
  
  ![CleanShot 2024-12-22 at 21 13 02@2x](https://github.com/user-attachments/assets/c85bbb35-5eb9-43bd-a47b-6454ab72b811)

- 캐싱 프록시는 실제 DB 부하 트래픽을 줄이고 응답 속도를 빠르게 할 수 있음
- 이외에도 HTTP 응답에 Gzip 압축 적용, 클라이언트 캐시 헤더 추가, 등의 여러 용도로 활용이 가능함

## 20.4 클라우드 네이티브 리버스 프록시
- 지금까지 알아본 리버스 프록시는 엔진엑스 였음
- 엔진엑스는 컨테이너와는 무관한 기술이다 보니 도커 네트워크와 통합되지는 않음
- 따라서, 클라우드 리버스 프록시 도구인 트래픽(Traefik)은 도커 엔진과 연결된 컨테이너 정보를 도커 API를 통해 가져올 수 있어 컨테이너용 리버스 프록시로 동작함
- 트래픽을 이용하면 애플리케이션별로 설정 파일을 따로 둘 필요 없이 컨테이너에 레이블을 추가하기만 하면됨. 그러면 이 레이블을 통해 스스로 설정과 라우팅 맵을 구성함

- 트래픽과 같은 컨테이너 용 프록시의 가장 큰 장점은 동적 설정을 구성할 수 있다는 점임
- 트래픽이 새로운 컨테이너를 모니터링하기 때문에 트래픽 실행 전에 모든 어플리케이션을 실행해두지 않아도됨
- 또한, 애플리케이션 설정이 변경되더라도 트래픽을 재실행 할 필요가 없음

- 최신 근황 비교(https://cast.ai/blog/traefik-vs-nginx/)
  - `Traefik의 장점` 
    - 내장된 마이크로서비스 배포를 갖춘 클라우드 네이티브 솔루션
    - Nginx에 비해 가볍고 단순함
    - 자동 검색을 통해  HTTP, UDP 및 TCP 트래픽에 대한 경로 설정 지원
  
  - `Traefik의 단점`
    - Traefik은 부하 분산 및 프록시 기능만 제공함
    - Nginx에 비해 문서가 적고 세부적인 제어가 부족함
    - Kubernetes Ingress 컨트롤러는 타사의 추가 기능임
  
  - `Nginx의 장점`
    - 업계에서 널리 사용되는 표준
    - 더욱 세밀화된 정보와 리소스 관리
    - 신뢰성과 속도가 우수함
    - TCP, UDP 및 HTTP 트래픽 지원  
    - Kubernetes의 인그레스 컨트롤러 지원을 관리하고 유지함
  
  - `Nginx의 단점` 
    - 클라우드 네이티브 솔루션이 아님
    - 기본 웹 사용자 인터페이스 없음 
    - 설정은 다소 복잡할 수 있음
    - 자동 서비스 검색 없음(수동 라우팅 정책)
   
  - 최근에는 Nginx Proxy Manager를 통해서 GUI를 기반으로 관리할 수 있어서 Traefik 보다 NGINX를 사용하는 경우가 많은 것 같음

## 20.5 리버스 프록시를 활용한 패턴의 이해
- 여러개의 어플리케이션을 운영하게 되면 리버스 프록시는 거의 필수적으로 도입해야함
- 이번 파트에서 배운 리버스 프록시의 다양한 고급 기능(SSL, 캐싱 프록시, 스티키 세션, 등)을 활용하는 법을 정리함

- **`첫번째 패턴`**
  - 클라이언트 요청에 포함된 호스트명을 통해 HTTP 혹은 HTTPS로 제공되는 애플리케이션에서 적합한 콘텐츠를 제공하는 패턴 

  ![CleanShot 2024-12-22 at 21 35 03@2x](https://github.com/user-attachments/assets/2680dd83-6d34-4c97-8bf2-aa5cb3c4499c)

- **`두번째 패턴`**
  - 한 애플리이션이 여러 개의 컨테이너에 걸쳐 실행될때 HTTP 요청의 경로를 이용해 요소 중 일부만 선택적으로 노출하는 패턴
  - 마이크로 서비스 아키텍처에서 주로 활용됨
  - 외부에서 보면 애플리케이션은 하나의 도메인을 갖지만, 경로에 따라 서로 다른 컨테이너가 요청을 처리하는 구조

  ![CleanShot 2024-12-22 at 21 35 23@2x](https://github.com/user-attachments/assets/2115d435-8cfb-4eb7-93dc-63e220e3bf48)

- **`세번째 패턴`**
  - 리버스 프록시를 애플리케이션의 단일 엔드포인트(프론트/클라이언트의 역할)로 두고 이후 추가되는 기능을 추가한 컨테이노 분할하는 패턴
  - URL에 따라 라우팅(ex. v1 -> v2) 
  - 모놀리식 설계를 사진 애플리케이션을 컨테이너로 이주시킬 때 유용한 패턴 

  ![CleanShot 2024-12-22 at 21 35 39@2x](https://github.com/user-attachments/assets/46136737-2536-4294-bbcf-3e6ed483dea0)

- 이러한 패턴들은 여러 가지를 적용하는 것도 가능함
- 하나의 클러스터 안에서 여러 개의 도메인과 연결된 모놀리식 설게 애플리케이션과 마이크로 서비스를 리버스 프록시를 이용해 함께 서비스하는것도 가능


### 추가로 알아보면 좋을 것들
- `Nginx vs Traefik`
  - https://bestcloudplatform.com/choosing-the-right-tool-a-detailed-traefik-vs-nginx-showdown/
- Reverse Proxy vs API Gateway
  - https://medium.com/@apurvaagrawal_95485/api-gateway-vs-reverse-proxy-049b359266d4
