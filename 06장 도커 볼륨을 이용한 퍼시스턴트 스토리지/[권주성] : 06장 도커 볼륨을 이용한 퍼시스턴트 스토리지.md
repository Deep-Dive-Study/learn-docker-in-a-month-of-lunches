# 06장 도커 볼륨을 이용한 퍼시스턴트 스토리지
- 도커로 유상태 어플리케이션을 다루기 위해서는 컨테이너의 파일 시스템에 대한 이해가 필요함

## 6.1 컨테이너 속 데이터가 사라지는 이유
- 모든 도커 컨테이너에는 단일 드라이브로 된 독립된 파일 시스템이 있음
  - 컨테이너를 종료해도 파일 시스템은 삭제되지 않음

- docker container cp 명령으로 컨테이너와 로컬 컴퓨터 간에 파일을 복사할 수 있음

- 예제 실행
  ```bash
  #컨테이너 실행
  docker container run —name rn1 diamol/ch06-random-number
  
  #컨테이너 내부 파일을 로컬로 복사
  docker container cp rn1:/random/number.txt numberl.txt
  ```

- 도커 컨테이너에 있는 파일 시스템은 도커가 여러 출처로부터 합쳐 만들고 컨테이너에 전달한 가상 파일 시스템임
- 이 출처는 기본적으로 이미지 레이어와 컨테이너 기록 가능 레이어로 구성됨
  - 이미지 레이어는 공유하지만, 기록 가능 레이어는 컨테이너마다 다름
  - 기록 가능 레이어는 컨테이너와 같은 생애주기를 가짐(생성시 같이 생성, 삭제시 같이 삭제됨)
  - 참고로, 컨테이너는 종료된다고 삭제되는 것은 아님(그래서 종료된 컨테이너의 데이터가 남아 있는것) 

  ![CleanShot 2024-11-17 at 20 42 40@2x](https://github.com/user-attachments/assets/d3dcc998-5017-4e09-9c6b-35aad6f5543c)

- 이미지 레이어에 포함된 파일을 수정할 수 있음
  - 쓰기 가능 레이어로 복사해 온 다음 쓰기 가능 레이어에서 파일을 수정
  - 이를 기록 중 복사(copy-on-write) 라고 함

## 6.2 도커 볼륨을 사용하는 컨테이너 실행하기
- 컨테이너가 대체되더라도 지속되어야 하는 데이터를 저장할 수 있는 방법이 필요함
- 이를, 도커 볼륨을 통해서 가능함
- 도커 볼륨은 도커에서 스토리지를 다루는 단위(컨테이너를 위한 USB 메모리)
  - 컨테이너와 독립적으로 존재하며 별도의 생애주기를 가지고, 컨테이너에 연결이 가능함 

- 컨테이너에서 볼륨을 사용하는 방법
  - 수동으로 직접 볼륨을 생성해 컨테이너에 연결하는 방법
  - Dockerfile 스크립트에서 VOLUME 인스트럭션을 사용하는 방법
    - ex) VOLUME <target-directory>

Cmd **VOLUME**
```
VOLUME [target directory]
```
**VOLUME 인스트럭션 예시**
```
FROM   diamol/dotnet-aspnet 
WORKDIR  /app
ENTRYPOINT  ["dotnet",  "ToDoList.dll"] 

VOLUME  /data
# 윈도 컨테이너라면 C：\data 에 Volume이 생성된다.

COPY  —from=builder /out/ .
```

- 도커 이미지에서 볼륨을 정의하면 컨테이너를 생성할 때마다 새로운 볼륨을 만듬
- volumes-from 플래그를 적용하면 다른 컨테이너의 볼륨을 연결할 수 있음 

- 다만, 볼륨은 컨테이너 간 파일 공유보다는 업데이트 간 상태를 보존하기 위한 용도로 사용해야하며, 이미지에서 정의하는 것보다는 명시적으로 관리하는 편이 더 나음
- 볼륨에 이름을 붙여 생성하고 업데이트 시 다른 컨테이너로 옮겨 연결하면 됨

- Dockerfile 스크립트의 VOLUME 인스트럭션과 docker container의 --volume 플래그는 별개 기능임!
- 인스트럭션을 사용해 빌드된 이미지에 볼륨을 지정하지 않는 경우 항상 새로운 볼륨을 함께 생성함 (이 볼륨을 재사용하려면 이 식별자를 미리 기억해야함)
- 반면에, --volume 플래그는 이미지에 볼륨이 정의 돼 있든 말든 지정된 볼륨을 컨테이너에 마운트함
  - 이미지에 볼륨이 정의돼 있더라도 이 정의가 무시되고 새로운 볼륨이 생기지 않음

- 따라서, 사용시에는 안전장치로 VOLUME 인스트럭션 지정해두되, 이미지의 기본 볼륨 설정에 의존하지 말고 별도로 이름을 붙여 만든 볼륨만을 사용하는 것이 좋음

## 6.3 파일 시스템 마운트를 사용하는 컨테이너 실행하기
- 볼륨은 호스트 컴퓨터와는 분리되어 있음
- 호스트의 스토리지를 컨테이너에 좀 더 직접적으로 연결하고 싶은 경우가 있음
- 이러한 경우에 바인드 마운트 수단을 사용하면됨
  - 바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만듬

- 도커를 사용하는 입장에서는 컨테이너에서 호스트 컴퓨터의 파일에 직접 접근이 가능해지고, 그 반대의 경우도 가능해지기 때문에 더욱 많은 작업을 할 수 있게됨
  - 이러한 방법을 이용해 이미지를 수정하지 않고 애플리케이션의 설정을 변경하는 작업이 가능함 

- 호스트 컴퓨터에서 접근 가능한 파일 시스템이라면 무엇이든 컨테이너에서도 사용할 수 있기 때문에
- 이를 이용해 분산 네트워크 파일 시스템이나, 고신뢰성 스토리지에 연결하여 사용할 수 있음

- 다만, 컨테이너는 대개 최소 권한을 가진 계정으로 실행되는데, 호스트 컴퓨터 파일에 접근하기 위해서는 권한 상승이 필요함
  - Dockerfilea 스크립트에서는 USER 인스트럭션을 사용해 컨테이너에 관리자 권한을 부여할 수 있음

## 6.4 파일 시스템 마운트의 한계점
- 이미 존재하는 대상 디렉터리에 마운트하면 마운트의 원본 디렉터리가 기존 디렉터리를 완전히 대체함
- 윈도우와 리눅스 컨테이너 간의 동작이 일치하지 않는 상황이 발생할 수 있음
- 분산 파일 시스템을 컨테이너에 바인드 마운트하는 경우 일부 기능을 지원하지 않는 동작이 있는 경우가 생김

  ![CleanShot 2024-11-17 at 21 08 34@2x](https://github.com/user-attachments/assets/b1e93c64-848b-4048-949c-c8afa226b76a)

- 해당 문제는 아직 회피할 방법이 없기 때문에 사용할 때 주의가 필요함

## 6.5 컨테이너의 파일 시스템은 어떻게 만들어지는가?
- 모든 컨테이너는 도커가 다양한 출처로부터 모아 만든 단일 가상 디스크로 구성된 파일 시스템을 갖음
- 이 파일 시스템을 유니언 파일 시스템이라고 함
  - 운영체제마다 구현은 다름

- 컨테이너는 유니언 파일 시스템을 통해 물리적 위치가 서로 다른 파일과 디렉터리에 마치 단일 디스크를 사용하듯 접근할 수 있음

  ![CleanShot 2024-11-17 at 21 12 18@2x](https://github.com/user-attachments/assets/7048bbc8-f1da-4d6d-a2cf-c8e2ea3806e2)

  - 컨테이너에서 실행되는 애플리케이션의 입장에서는 단일 디스크만 볼 수 있지만, 컨테이너나 이미지를 생성해서 사용하는 사용자는 여러 출처를 합쳐서 이 디스크를 구성할 수 있음
  - 여러개의 이미지 레이어, 하나 이상의 볼륨 마운트와 바인드 마운트를 컨테이너에 연결할 수 있음
  - 다만, 기록 가능 레이어는 하나밖에 가질 수 없음
 
- 컨테이너의 스토리지를 구성할 때 고려해야하는 일반론
  - `기록 가능 레이어`
    - 비용이 비싼 계산이나 네트워크를 통해 저장해야하는 데이터의 캐싱 등 단기 저장에 적합함
    - 컨테이너가 삭제되면 여기 저장된 데이터는 유실됨
  - `로컬 바인드 마운트`
    - 호스트 컴퓨터와 컨테이너 간 데이터를 공유하기 위해 사용
    - 로컬 컴퓨터에서 수정한 소스코드를 추가 이미지 빌드 없이 즉시 컨테이너로 전달 가능
  - `분산 바인드 마운트`
    - 네트워크 스토리지와 컨테이너 간에 데이터를 공유하기 위해 사용
    - 가용성 높지만 지원하지 않는 경우 있으며, 성능면에서 차이가 있을 수 있음
    - 읽기 전용으로 설정 파일을 전달하거나 캐시로 활용 가능
    - 읽기 및 쓰기 가능으로 데이터를 저장해 네트워크 상의 모든 컨테이너에 데이터를 공유하는 용도로 사용 가능
  - `볼륨 마운트`
    - 컨테이너와 볼륨 간에 데이터를 공유하기 위해 사용
    - 볼륨에 데이터를 영구 저장
    - 컨테이너 교체시에 이전 버전 컨테이너의 데이터를 그대로 유지 가능
  - `이미지 레이어`
    - 컨테이너의 초기 파일 시스템 구성
    - 적층 구조를 가짐
    - 후속 레이어와 이전 레이어의 내용이 서로 충돌하는 경우 후속 레이어의 내용이 적용됨
    - 읽기 전용으로 여러 컨테이너가 공유함

## 6.6 연습 문제

