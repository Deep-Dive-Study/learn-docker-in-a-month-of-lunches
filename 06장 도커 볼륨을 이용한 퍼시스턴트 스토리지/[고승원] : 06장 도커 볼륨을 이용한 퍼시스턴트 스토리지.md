컨테이너는 무상태 애플리케이션에게는 최적의 실행 환경이다.

클러스터에 실행 중인 컨테이너의 수를 늘리기만 하면, 모든 요청을 똑같이 처리하기 때문이다.

도커여도 스토리지가 관련되면 복잡한 상황이 생긴다.

# 6.1 컨테이너 속 데이터가 사라지는 이유

도커 컨테이너에도 단일 드라이브로 된 파일 시스템이 있다. → 컨테이너 디스크

모든 컨테이너는 독립된 파일 시스템을 갖는다. 한 이미지를 여러 컨테이너에서 실행을 해도, 디스크의 내용은 다 달라진다.

![image](https://github.com/user-attachments/assets/9dfd62b2-c796-40f1-bd75-0d50ef60e086)

컨테이너의 파일 시스템은 단일 디스크이다. 이는 도커가 여러 출처로부터 합쳐 만들고 컨테이너에 전달한 가상 파일 시스템이다.

이 출처는 기본적으로 이미지 레이어와 컨테이너 기록 가능 레이어로 구성된다.

![image](https://github.com/user-attachments/assets/38d1409d-d7e9-4855-8de5-deabe9b4d9ee)

이미지 레이어

- 모든 컨테이너가 공유한다.
- 읽기 전용이다.

기록 가능 레이어

- 컨테이너마다 다르다.
- 컨테이너와 같은 생애주기를 갖는다. (컨테이너 실행시 생성 / 삭제시 삭제)
- 새 파일을 만들거나 읽기 전용 레이어의 파일을 수정할 때 사용한다.

컨테이너가 실행되고, 기록 가능 레이어에 값을 수정해도 이미지를 공유하는 다른 컨테이너나 이미지에는 영향이 없다.

실제로 컨테이너를 생성하고, 파일을 수정한 뒤 삭제하면 사라지고, 같은 이미지로 새로운 컨테이너를 생성하면 변경사항이 반영이 안되어있다.

![image](https://github.com/user-attachments/assets/112ff5ea-ea07-4e62-ad90-d4fc8a4338ad)

# 6.2 도커 볼륨을 사용하는 컨테이너 실행하기

도커 볼륨 : 컨테이너를 위한 USB 메모리

- 컨테이너와 독립적으로 존재하며, 별도의 생애주기를 갖는다.
- 컨테이너에 연결할 수 있다. (파일시스템의 디렉터리가 됨)

컨테이너에서 볼륨을 사용하는 방법

- 직접 볼륨을 생성해 컨테이너에 연결하는 방법
- Dockerfile 스크립트에서 VOLUME 인스트럭션을 사용하는 방법
    - VOLUME <target-directory> 형식

![image](https://github.com/user-attachments/assets/eccd2ca3-cb7d-4d12-888c-28255313f539)

위와 같이 Dockerfile을 작성하면 자동으로 볼륨을 생성해 컨테이너에 연결을 해준다.

![image](https://github.com/user-attachments/assets/3ac42137-2a0e-4c0c-9f7e-46da74a38469)

- 컨테이너를 생성해 볼륨에 연결한다.
- 컨테이너 정보를 확인하면 볼륨 정보를 볼 수 있다. (Mounts)
- 볼륨은 이미지나 컨테이너 처럼 docker volume 명령을 통해 확인/삭제할 수 있다.

실습을 해보면, 컨테이너 간 볼륨을 연결하면 동일한 볼륨을 사용하게 된다. 다만 한 파일에 여러 컨테이너가 동시에 접근하면 애플리케이션이 비정상적으로 동작할 수 있다.

![image](https://github.com/user-attachments/assets/f6b619c2-c9de-4697-8c8b-5f90a1c49cb5)

컨테이너를 삭제해도 볼륨이 남아있기 때문에, 새로운 컨테이너에 볼륨을 마운트하면 데이터는 그대로 보존된다.

 Dockerfile의 VOLUME 인스트럭션과 docker container의 —volume 플래그는 별개의 기능이다.

- VOLUMN 인스트럭션으로 생성된 볼륨은 매번 재생성 되기 때문에 원하는 볼륨을 마운트하려면 볼륨 식별자를 알아야 한다.
- —volume 플래그는 이미지 볼륨 유무에 상관 없이 지정된 볼륨을 컨테이너에 마운트 한다. (이미지 볼륨이 없어도 실행되서 VOLUME 인스트럭션을 정의해놔도 좋다)

# 6.3 파일 시스템 마운트를 사용하는 컨테이너 실행하기

바인드 마운트 : 호스트의 파일 시스템의 디렉터리를 컨테이너에 파일 시스템의 디렉터리로 만든다.

- 컨테이너가 호스트 컴퓨터 파일에 직접 접근할 수 있고, 그 반대도 가능하다.
- 호스트 컴퓨터의 파일 시스템을 명시적으로 지정해 컨테이너 데이터로 쓸 수 있다. (SSD, 분산스토리지 등)
- RAID가 적용된 디스크 어레이를 가진 서버도 가능하다.

바인드 마운트는 양방향으로 동작한다. 호스트 컴퓨터에서 만든 파일은 공격을 방지하기 위해 권한 상승이 필요하다. 그래서 USER 인스트럭션을 사용해 컨테이너에 관리자 권한을 부여한다.

파일을 수정할 필요가 없다면 최소 권한으로 부여할 수도 있다.

# 6.4 파일 시스템 마운트의 한계점

### 1. 컨테이너 마운트 대상 디렉터리가 존재하고, 이미지 레이어에 이 디렉터리 파일이 포함된 케이스

이미 존재하는 디렉터리에 마운트하면 마운트의 원본 디렉터리가 기존 디렉터리를 완전히 대체한다.

→ 그래서 이미지에 포함돼 있던 원래 파일은 사용할 수 없다.

### 2. 호스트 컴퓨터의 파일 하나를 컨테이너에 이미 존재하는 디렉터리로 마운트 하는 케이스

컨테이너 파일 시스템은 OS마다 동작이 다르다. 그러나 볼륨이나 바인드 마운스에서는 동작이 달라진다.

리눅스를 기준으로 기존과 동일하게 동작하나, 윈도우에선 다르게 동작한다.

### 3. 분산 파일 시스템을 컨테이너에 바인드하는 케이스

보통 분산 파일 시스템은 로컬 파일 스토리지가 아니라 S3같은 서비스를 사용하는 경우가 많다.

서비스가 링크 생성을 시도하다 실패해서 애플리케이션이 오류를 일을킨다.

![image](https://github.com/user-attachments/assets/2c43cb92-9f6c-420b-b89c-f3dc2183a1d8)

이 경우는 매우 드물지만, 회피할 도리가 없어 주의가 필요하다.

# 6.5 컨테이너의 파일 시스템은 어떻게 만들어지는가?

### 베스트 케이스를 알아보자

유니언 파일 시스템 : 모든 컨테이너가 갖는 도커가 다양한 출처로부터 모아 단일 가상 디스크 파일 시스템

컨테이너는 유니언 파일 시스템을 통해 물리적 위치가 서로 다른 파일과 디렉터리에 단일 디스크를 사용하듯 접근할 수 있다.

기록 가능 레이어는 하나만 가질 수 있어서, 컨테이너 스토리지를 구성할 때 고려할만한 일반론이다.

- 기록 가능 레이어 : 비용이 비싼 계산이나 캐싱 등 단기 저장에 적합하다. (컨테이너와 함께 사라짐)
- 로컬 바인드 마운트 : 호스트 컴퓨터와 컨테이너 간 데이터 공유용(이미지 빌드 없이 즉시 컨테이너로 전달 가능)
- 분산 바인드 마운트 : 네트워크 스토리지와 컨테이너 간 데이터 공유용, 가용성 높지만 지원하지 않는 경우 있음. 
읽기전용으로 사용하면 캐시, 읽기/쓰기 가능이면 데이터 공유용으로 적합하다.
- 볼륨 마운트 : 컨테이너와 볼륨 간에 데이터 공유용. 데이터 영구저장.
- 이미지 레이어 : 컨테이너 초기 파일 시스템 구성용. 후속과 이전 레이어가 충돌되면 후속 레이어의 내용이 적용된다. (읽기전용)

![image](https://github.com/user-attachments/assets/d981b654-91a6-4b31-9c03-7896124acbd1)

# 6.6 연습 문제

### 기본 실행

`docker container run -d -p 8100:80 diamol/ch06-lab` 

![image](https://github.com/user-attachments/assets/a107a0a3-c6f8-4632-8d4e-984c2ea23820)

`docker container run -d -p 8200:80 --mount type=bind,source=$(pwd)/solution,target=/app/config,readonly --volume ch06-lab:/new-data diamol/ch06-lab`

![image](https://github.com/user-attachments/assets/528f5f91-4256-4e20-b7c1-f2e3d041cfaa)
