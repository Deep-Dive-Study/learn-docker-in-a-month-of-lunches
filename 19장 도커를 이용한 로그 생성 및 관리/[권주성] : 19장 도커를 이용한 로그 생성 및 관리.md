# 19장 도커를 이용한 로그 생성 및 관리
- 도커의 로그 기본 원칙은 단순함
  - 도커는 **`표준 출력 스트림`** 을 통해 로그를 수집하고 있음

- 도커는 컨테이너 로그가 표준 출력 스트림을 통해 출력 중이라면 출력된 로그를 원하는 곳으로 전달해줌
- 이를 활용하여 모든 컨테이너의 로그를 중앙 로그 저장소에 저장하고 수집된 로그를 검색하는 로그 시스템을 구축 가능
  - Ex) OpenTelemtry, ELK, Grafana LGTM, 등 

  ![CleanShot 2024-12-22 at 20 13 58@2x](https://github.com/user-attachments/assets/f68ec8bc-6a94-4bb7-91e0-71f5ad1a935e)

  ![image4-1-1024x645](https://github.com/user-attachments/assets/6cbd2dc8-40b3-4b1c-a0a6-ebc3ce459716)

- 다만, 로그 시스템을 구축하는 방법에 대해서는 다루지 않기 때문에 따로 **`관찰 가능성(Observability)`** 이라는 카테고리의 책들을 참고 하기 바람

## 19.1 표준 에러 스트림과 표준 출력 스트림
- 도커 이미지는 애플리케이션 바이너리 및 의존성, 그리고 컨테이너를 시작할 때 도커가 실행할 프로세스에 대한 정보 등을 담은 파일 시스템의 스냅샷임
- 이미지를 실행하면 동작하는 프로세스는 터미널의 입력과 출력을 통제함
- 실행된 프로세스에서 생성한 로그 엔트리는 표준 출력(stdout) 및 표준 오류(stderr) 스트림으로 출력됨
  - 우리가 터미널에서 애플리케이션의 출력 내용을 볼 수 있는 이유임

- 즉, 도커는 각 컨테이너의 표준 출력(stdout) 및 표준 오류(stderr) 스트림을 주시하며 스트림을 통해 출력되는 내용을 수집함

  ![CleanShot 2024-12-22 at 20 30 34@2x](https://github.com/user-attachments/assets/f36ac4dc-0e2b-4cbd-a657-e85bbf0fd6ef)

  - 애플리케이션 프로세스가 포어그라운드로 실행되고 로그를 stdout로 출력하는 방식의 패턴은 표준적인 컨테이너 운영 모델임(JVM, Go 바이너리 등도 동일)

- 도커의 로그 설정 옵션을 통해 JSON 출력, 롤링 업데이트, 등의 다양한 설정을 적용할 수 있음
  - 컨테이너 옵션을 통해 관리하기 보다는 로깅 프레임워크(Logback, 등)을 통해 관리하지 않을까? 

## 19.2 다른 곳으로 출력된 로그를 stdout 스트림에 전달하기
- 표준 로그 모델을 적용하기 어려운 어플리케이션의 경우는 도커가 직접 로그를 수집하지 못하기 때문에 로그 파일의 내용을 읽어 표준 출력으로 내보내 주는 별도의 프로세스를 활용해야함
  - ex) 리눅스 syslog, 윈도의 이벤트 로그, 등
 
- 별도의 프로세스를 컨테이너 시작 명령에서 실행하면 되는데 이 프로세스는 셸 스크립트 또는 간단한 유틸리티, 등 어떤 형태여도 무방함
  - 다만, 컨테이너 시작 시퀀스에서 마지막으로 실행된 프로세스이기만 하면됨
 
  ![CleanShot 2024-12-22 at 20 39 08@2x](https://github.com/user-attachments/assets/5406ce6d-19b0-403b-bded-84d42feeb6f2)

- 해당 방식의 단점은 유틸리티가 문제를 일으키면 어플리케이션이 영향을 받을 수 있음
- 또한, 어플리케이션이 종료되어도 유틸리티만 동작해서 컨테이너 자체가 종료되지 않을 수 있음
- 이러한 문제가 있을수 있음을 감안하여 안정적으로 동작하는 프로세스를 세심하게 작성해야함

## 19.3 컨테이너 로그 수집 및 포워딩하기
- 앞선 내용을 통해, 모든 이미지에서 컨테이너 로그를 수집할 준비가 끝났다면 모든 컨테이너에서 수집된 로그를 종합할 수 있는 도커의 플러그인 로깅 시스템을 적용해볼 차례
- 컨테이너의 로그를 포워딩(전달)하기 위한 프로그램은 여러가지가 있음(Ex. Fluentd, Elastic Beats, Opentelemetry, 등)

  ![CleanShot 2024-12-22 at 20 45 14@2x](https://github.com/user-attachments/assets/2bf9b6c1-7a69-4eb5-8674-1f2e89efc159)

- 실습은 현재 도입 예정 중인 Opentelemetry를 활용함(Docker-Compose로 구성)

  ![img](https://github.com/user-attachments/assets/e8dd9407-9834-4265-a0da-d32627f8ae4e)

  ![IntelliJ IDEA 2024-12-22 22 01 30](https://github.com/user-attachments/assets/207c5a0a-f45c-4a3b-99c1-24fb5bf140d0)

  ![CleanShot 2024-12-22 at 22 04 41@2x](https://github.com/user-attachments/assets/53a576e8-91ae-435f-bf9a-23ece4f3f789)

  ![IntelliJ IDEA 2024-12-22 22 05 48](https://github.com/user-attachments/assets/be5a7997-ffa5-439e-a3de-c5ced66ab467)

  ![IntelliJ IDEA 2024-12-22 22 06 11](https://github.com/user-attachments/assets/cd7a700b-5d09-4051-8dc1-8f7e8a32fa1f)

## 19.4 로그 출력 및 로그 컬렉션 관리하기
- 로그는 대량의 불필요한 데이터 저장과 문제 진단에 필요한 정보 확보 사이의 줄타기와 같음
- 로그를 필터링하여 저장한다면 이러한 균형을 맞추는데 도움이 될 수 있음 
- 필터링을 통해 로그를 분리하여 저장하고 시각화하는 전략은 애플리케이션의 핵심 로그와 '있으면 좋은 정도'의 로그를 분리하는데 도움이됨
  - Ex. 가장 중요한 컴포넌트의 로그는 카프카, 사용자 로그는 엘라스틱 서치, 그 외 로그는 S3에 저장하는 방식
 
- 로깅 시스템을 변경할 때는 어플리케이션을 재배포 하는 것이 나음
  - 그 사이에 로그를 저장하지 못하는 문제가 발생할 수 있기 때문에 

## 19.5 컨테이너의 로깅 모델
- 도커의 로깅 모델은 매우 유연성이 뛰어나지만, 해당 유연성은 애플리케이션 로그를 컨테이너 로그로 내보낼 때만 적용됨
- 따라서, 모든 애플리케이션 로그는 컨테이너 로그로 출력하는 것이 좋음
- 해당 파트에서는 EFK 스택(Elastic Search + Fluentd, Kibana)를 사용하였음

  ![CleanShot 2024-12-22 at 20 19 43@2x](https://github.com/user-attachments/assets/a4fd9f2d-fa35-4f30-a098-10ba146ded7b)

  ![image4-1-1024x645](https://github.com/user-attachments/assets/6cbd2dc8-40b3-4b1c-a0a6-ebc3ce459716)

- 애플리케이션 로그를 stdout 스트림으로 출력하고 플랫폼을 이용해 로그르 수집, 강화, 필터링, 저장하는 방법은 단순하면서도 유연한 방법임

- 회사에 따라서는 로그를 바로 최종 저장소로 보내는 것을 선호하는 곳도 있음
  - 다만, 이는 유연하지 않기 때문에 중앙 집중형 플랫폼을 사용하여 로그를 수집하는 것이 좋음(추후 수정에도 용이함) 


